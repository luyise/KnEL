// Constantes primitives du langage.
// Merci de ne pas bidouiller le fichier de façon random ^^

// On défini Ord : une version constructive des ordinaux,
// qui va nous servir à indexer les Types dans lesquels
// seront formalisés la plupart des raisonnements.
// Puisqu'on ne devrait jamais avoir à considérer le type de Ord,
// on ne le donne pas.

Ord : _;

// Les univers sont tous plongés dans Type_∞,
// distinguer Type_∞ de _ ou Ord permet d'éviter d'avoir
// au même niveau Ord et ses éléments, et donc de faire de
// l'autoréférence avec le constructeur OrdSup défini plus bas.

Type_∞ : _;

// Ord vient avec un unique constructeur ; OrdSup.
// Intuitivement, OrdSup prend une (petite) famille d'éléments
// de Ord et renvoie le plus petit élément de Ord qui les majore tous strictements.

OrdSup : Π (A : Type_∞), (A → Ord) → Ord;

// On défini un ordre sur Ord afin de préciser cette idée.

OrdLe : Ord → Ord → _;
OrdLe_sup_sup :
  Π (A B : Type_∞) (f : A → Ord) (g : B → Ord),
    (Π (x : A), Σ (y : B), OrdLe (f x) (g y))
    → OrdLe (sup A f) (sup B g);

// On définit à partir de OrdLe un ordre strict sur Ord,
// on montrera plus tard qu'il se comporte comme attendu :
// Notamment il est bien fondé.

OrdLt : Ord → Ord → _;
OrdLt α (sup B g) = Σ (b : B), (OrdLe α (g b));

// On a besoin aussi de void, et de unit.

Void : Type_∞
Unit : Type_∞
point : Unit

Void_rec : Π (P : Void → _) (x : Void), P x
Unit_rec : Π (P : Unit → _) (p : P point),
  Π (x : Unit), P x

OrdSuc : Ord → Ord
OrdSuc α = OrdSup (Unit_rec (λ _ → Ord) α)